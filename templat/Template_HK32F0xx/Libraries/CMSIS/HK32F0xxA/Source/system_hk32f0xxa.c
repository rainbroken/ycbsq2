/*******************************************************************************
* @copyright: Shenzhen Hangshun Chip Technology R&D Co., Ltd
* @filename:  system_hk32f0xxa.c
* @brief:     CMSIS Cortex-M0 Device Peripheral Access Layer System Source File.
*             This file contains the system clock configuration for HK32F0xxA devices,
*             and is generated by the clock configuration tool    
*             1.  This file provides two functions and one global variable to be called from
*             user application:
*             - SystemInit(): Setups the system clock (System clock source, PLL Multiplier
*             and Divider factors, AHB/APBx prescalers and Flash settings),
*             depending on the configuration made in the clock xls tool.
*             This function is called at startup just after reset and
*             before branch to main program. This call is made inside
*             the "startup_hk32f0xx.s" file.  
*             - SystemCoreClock variable: Contains the core clock (HCLK), it can be used
*             by the user application to setup the SysTick
*             timer or configure other parameters.  
*             - SystemCoreClockUpdate(): Updates the variable SystemCoreClock and must
*             be called whenever the core clock is changed
*             during program execution.   
*             2. After each device reset the HSI (8 MHz Range) is used as system clock source.
*             Then SystemInit() function is called, in "startup_hk32f0xx.s" file, to
*             configure the system clock before to branch to main program.   
*             3. If the system clock source selected by user fails to startup, the 
*             SystemInit() function will do nothing and HSI still used as system clock source. User 
*             can add some code to deal with this issue inside the SetSysClock() function.       
*             4. The default value of HSE crystal is set to 8MHz, refer to "HSE_VALUE" define
*             in "hk32f0xxa.h" file. When HSE is used as system clock source, directly or
*             through PLL, and you are using different crystal you have to adapt the HSE
*             value to your own configuration.     
*             5. This file configures the system clock as follows:
*             =============================================================================
*             =============================================================================
*             SYSCLK(Hz)                             | 56000000
*             -----------------------------------------------------------------------------
*             HCLK(Hz)                               | 56000000
*             -----------------------------------------------------------------------------
*             AHB Prescaler                          | 1
*             -----------------------------------------------------------------------------
*             APB Prescaler                          | 1
*             -----------------------------------------------------------------------------
*             HSE Frequency(Hz)                      | 8000000
*             ----------------------------------------------------------------------------
*             PREDIV                                 | 1
*             -----------------------------------------------------------------------------
*             Flash Latency(WS)                      | 1
*             -----------------------------------------------------------------------------
*             Prefetch Buffer                        | ON
*             -----------------------------------------------------------------------------
* @author:    AE Team
* @version:   V1.0.0/2023-10-08
*             1.Initial version
* @log:
*******************************************************************************/


/* Includes ------------------------------------------------------------------*/
/** @addtogroup CMSIS
  * @{
  */

/** @addtogroup HK32F0xxA_system
  * @{
  */

/** @addtogroup HK32F0xxA_System_Private_Includes
  * @{
  */

#include "hk32f0xxa_conf.h"
#include "hk32f0xxa_flash.h"
#include "hk32f0xxa_gpio.h"

/**
  * @}
  */


/*******************************************************************************
*  Clock Definitions
*******************************************************************************/
#if( SYSCLK_SOURCE == SYSCLK_SRC_PLL )

#if defined SYSCLK_HSE8M_PLL_FREQ_24MHz
uint32_t SystemCoreClock           = SYSCLK_HSE8M_PLL_FREQ_24MHz;           /*!< System Clock Frequency (Core Clock) */
static void SetSysClockTo24_HSE8M_PLL(void);
#elif defined SYSCLK_HSE8M_PLL_FREQ_48MHz
uint32_t SystemCoreClock           = SYSCLK_HSE8M_PLL_FREQ_48MHz;           /*!< System Clock Frequency (Core Clock) */
static void SetSysClockTo48_HSE8M_PLL(void);
#elif defined SYSCLK_HSE8M_PLL_FREQ_72MHz
uint32_t SystemCoreClock         = SYSCLK_HSE8M_PLL_FREQ_72MHz;             /*!< System Clock Frequency (Core Clock) */
static void SetSysClockTo72_HSE8M_PLL(void);
#elif defined SYSCLK_HSE8M_PLL_FREQ_96MHz
uint32_t SystemCoreClock         = SYSCLK_HSE8M_PLL_FREQ_96MHz;             /*!< System Clock Frequency (Core Clock) */
static void SetSysClockTo96_HSE8M_PLL(void);
#elif defined SYSCLK_HSI_PLL_FREQ_48MHz
uint32_t SystemCoreClock           = SYSCLK_HSI_PLL_FREQ_48MHz;             /*!< System Clock Frequency (Core Clock) */
static void SetSysClockTo48_HSI_PLL(void);
#elif defined SYSCLK_HSI_PLL_FREQ_64MHz
uint32_t SystemCoreClock           = SYSCLK_HSI_PLL_FREQ_64MHz;             /*!< System Clock Frequency (Core Clock) */
static void SetSysClockTo64_HSI_PLL(void);
#elif defined SYSCLK_HSI_PLL_FREQ_72MHz
uint32_t SystemCoreClock           = SYSCLK_HSI_PLL_FREQ_72MHz;             /*!< System Clock Frequency (Core Clock) */
static void SetSysClockTo72_HSI_PLL(void);
#elif defined SYSCLK_HSI_PLL_FREQ_96MHz
uint32_t SystemCoreClock             = SYSCLK_HSI_PLL_FREQ_96MHz;           /*!< System Clock Frequency (Core Clock) */
static void SetSysClockTo96_HSI_PLL(void);
#endif

#elif( SYSCLK_SOURCE == SYSCLK_SRC_HSE | SYSCLK_SOURCE == SYSCLK_SRC_HSE_BYPASS)
uint32_t SystemCoreClock         = SYSCLK_FREQ_HSE;                            /*!< System Clock Frequency (Core Clock) */
static void SetSysClockToHSE(void);
#elif( SYSCLK_SOURCE == SYSCLK_SRC_HSI8M)
uint32_t SystemCoreClock         = SYSCLK_FREQ_HSI_8M;                         /*!< System Clock Frequency (Core Clock) */
static void SetSysClockToHSI_8M(void);
#elif( SYSCLK_SOURCE == SYSCLK_SRC_HSI14M)
uint32_t SystemCoreClock         = SYSCLK_FREQ_HSI_14M;                        /*!< System Clock Frequency (Core Clock) */
static void SetSysClockToHSI_14M(void);
#elif( SYSCLK_SOURCE == SYSCLK_SRC_HSI56M)
uint32_t SystemCoreClock         = SYSCLK_FREQ_HSI_56M;                        /*!< System Clock Frequency (Core Clock) */
static void SetSysClockToHSI_56M(void);
#elif( SYSCLK_SOURCE == SYSCLK_SRC_EXTCLK_IO)
uint32_t SystemCoreClock         = SYSCLK_FREQ_EXTCLK;                         /*!< System Clock Frequency (Core Clock) */
static void SetSysClockToEXTCLK(void);
#elif( SYSCLK_SOURCE == SYSCLK_SRC_LSI)
uint32_t SystemCoreClock         = SYSCLK_FREQ_LSI;                         /*!< System Clock Frequency (Core Clock) */
static void SetSysClockToLSI(void);
#elif( SYSCLK_SOURCE == SYSCLK_SRC_LSE)
uint32_t SystemCoreClock         = SYSCLK_FREQ_LSE;                         /*!< System Clock Frequency (Core Clock) */
static void SetSysClockToLSE(void);

#endif

/** @addtogroup HK32F0xxA_System_Private_Variables
  * @{
  */
__I uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};

/**
  * @}
  */

/** @addtogroup HK32F0xxA_System_Private_FunctionPrototypes
  * @{
  */

static void SetSysClock(void);

/**
  * @}
  */

/** @addtogroup HK32F0xxA_System_Private_Functions
  * @{
  */

/**
  * @brief  Setup the microcontroller system.
  *         Initialize the Embedded Flash Interface, the PLL and update the
  *         SystemCoreClock variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
    /* Set HSION bit */
    RCC->CR |= (uint32_t)0x00000001;
    /* Reset SW[1:0], HPRE[3:0], PPRE[2:0] MCO[3:0] and MCOSEL[2:0] bits */
    RCC->CFGR &= (uint32_t)0x00FFF80C;
    /* Reset HSEON, CSSON and PLLON bits */
    RCC->CR &= (uint32_t)0xFEF6FFFF;
    /* Reset HSEBYP bit */
    RCC->CR &= (uint32_t)0xFFFBFFFF;
    /* Reset USART1SW[1:0], I2C1SW bits ,USART2SW[1:0]*/
    RCC->CFGR3 &= (uint32_t)0xFFFCFFEC;
    /* Reset HSI16 bit */
    RCC->CR2 &= (uint32_t)0xFFFFFFFE;
    /* Disable all interrupts */
    RCC->CIR = 0x00000000;
    FLASH->INT_VEC_OFFSET = VECT_TAB_OFFSET;  
    RCC->APB1ENR |= RCC_APB1Periph_PWR;
    
    //  *(uint32_t *)((uint32_t)0x4000704C) =  0x1985;
    //  for(int i = 0;i<100;i++);
    //  *(uint32_t *)((uint32_t)0x4000704C) =  0x0429;
    *(volatile uint32_t *) ((uint32_t)0x4000704C ) = 0x1985;
    *(volatile uint32_t *) ((uint32_t)0x4000704C ) = 0x0429;
    *(uint32_t *)((uint32_t)0x40007070) = ((*(uint32_t *)((uint32_t)0x40007070)) & 0xFFFF00FF) | ((*(uint32_t *)0x1ffff7ec) & 0x0000ff00);
    *(uint32_t *)((uint32_t)0x40007070) = ((*(uint32_t *)((uint32_t)0x40007070)) & 0xFFFFFF00) | ((*(uint32_t *)0x1ffff7ec) & 0x000000ff);
    *(uint32_t *)((uint32_t)0x40007074) = ((*(uint32_t *)((uint32_t)0x40007074)) & 0xFFFFF000) | ((*(uint32_t *)0x1ffff7e8) & 0x00000fff);
    *(uint32_t *)((uint32_t)0x40007060) = ((*(uint32_t *)((uint32_t)0x40007060)) & 0xFFFFF000) | ((*(uint32_t *)0x1ffff7e4) & 0x00000fff);
    //*(uint32_t *)((uint32_t)0x40007064)= ((*(uint32_t *)((uint32_t)0x40007064))&0xFFFFF000) | ((*(uint32_t *)0x1ffff7e0)&0x00000fff);
    *(uint32_t *)((uint32_t)0x40007068) = ((*(uint32_t *)((uint32_t)0x40007068)) & 0xFFFFFF00) | ((*(uint32_t *)0x1ffff7dc) & 0x000000ff);
    *(uint32_t *)((uint32_t)0x4000706C) = ((*(uint32_t *)((uint32_t)0x4000706C)) & 0xFFFFFF00) | (((*(uint32_t *)0x1ffff7dc) & 0x0000ff00) >> 8);
    *(uint32_t *)((uint32_t)0x40007074) = ((*(uint32_t *)((uint32_t)0x40007074)) | (0x01 << 13));
    *(uint32_t *)(0x4002111c) = (*(uint32_t *)0x1ffff7f8) >> 16; //LSI soft laod
    //  for(int i = 0;i<500;i++)
    //  {
    //     __NOP();
    //  }
    //  RCC->APB1ENR &= ~RCC_APB1Periph_PWR;
    /* Configure the System clock frequency, AHB/APBx prescalers and Flash settings */
    SetSysClock();
}

/**
  * @brief  Update SystemCoreClock according to Clock Register Values
  *         The SystemCoreClock variable contains the core clock (HCLK), it can
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  * @note   Each time the core clock (HCLK) changes, this function must be called
  *         to update SystemCoreClock variable value. Otherwise, any configuration
  *         based on this variable will be incorrect.
  * @note   - The system frequency computed by this function is not the real
  *         frequency in the chip. It is calculated based on the predefined
  *         constant and the selected clock source:
  *         - If SYSCLK source is HSI, SystemCoreClock will contain the HSI_VALUE(*)
  *         - If SYSCLK source is HSE, SystemCoreClock will contain the HSE_VALUE(**)
  *         - If SYSCLK source is PLL, SystemCoreClock will contain the HSE_VALUE(**)
  *         or HSI_VALUE(*) multiplied/divided by the PLL factors.
  *         (*) HSI_VALUE is a constant defined in HK32F0xxA.h file (default value
  *         8 MHz) but the real value may vary depending on the variations
  *         in voltage and temperature.
  *         (**) HSE_VALUE is a constant defined in HK32F0xxA.h file (default value
  *         8 MHz), user has to ensure that HSE_VALUE is same as the real
  *         frequency of the crystal used. Otherwise, this function may
  *         have wrong result.
  *         - The result of this function could be not correct when using fractional
  *         value for HSE crystal.
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
    uint32_t tmp = 0;
    /* Get SYSCLK source -------------------------------------------------------*/
    tmp = RCC->CFGR & RCC_CFGR_SWS;

    switch (tmp)
    {
        case 0x00:  /* HSI used as system clock */
            SystemCoreClock = HSI_VALUE;
            break;

        case 0x04:  /* HSE used as system clock */
            SystemCoreClock = HSE_VALUE;
            break;

        default: /* HSI used as system clock */
            SystemCoreClock = HSI_VALUE;
            break;
    }

    /* Compute HCLK clock frequency ----------------*/
    /* Get HCLK prescaler */
    tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
    /* HCLK clock frequency */
    SystemCoreClock >>= tmp;
}

/**
  * @brief  Configures the System clock frequency, AHB/APBx prescalers and Flash
  *         settings.
  * @note   This function should be called only once the RCC clock configuration
  *         is reset to the default reset state (done in SystemInit() function).
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
#if defined SYSCLK_FREQ_HSE
    SetSysClockToHSE();
#elif defined SYSCLK_HSE8M_PLL_FREQ_24MHz
    SetSysClockTo24_HSE8M_PLL();
#elif defined SYSCLK_HSE8M_PLL_FREQ_48MHz
    SetSysClockTo48_HSE8M_PLL();
#elif defined SYSCLK_HSE8M_PLL_FREQ_72MHz
    SetSysClockTo72_HSE8M_PLL();
#elif defined SYSCLK_HSE8M_PLL_FREQ_96MHz
    SetSysClockTo96_HSE8M_PLL();
#elif defined SYSCLK_HSI_PLL_FREQ_48MHz
    SetSysClockTo48_HSI_PLL();
#elif defined SYSCLK_HSI_PLL_FREQ_64MHz
    SetSysClockTo64_HSI_PLL();
#elif defined SYSCLK_HSI_PLL_FREQ_72MHz
    SetSysClockTo72_HSI_PLL();
#elif defined SYSCLK_HSI_PLL_FREQ_96MHz
    SetSysClockTo96_HSI_PLL();
#elif defined SYSCLK_FREQ_HSI_8M
    SetSysClockToHSI_8M();
#elif defined SYSCLK_FREQ_HSI_14M
    SetSysClockToHSI_14M();
#elif defined SYSCLK_FREQ_HSI_56M
    SetSysClockToHSI_56M();
#elif defined SYSCLK_FREQ_EXTCLK
    SetSysClockToEXTCLK();
#elif defined SYSCLK_FREQ_LSI
    SetSysClockToLSI();
#elif defined SYSCLK_FREQ_LSE
    SetSysClockToLSE();
#endif
    /* If none of the define above is enabled, the HSI is used as System clock
        source (default after reset) */
}

#if( SYSCLK_SOURCE == SYSCLK_SRC_HSE | SYSCLK_SOURCE == SYSCLK_SRC_HSE_BYPASS)
/**
  * @brief  Selects HSE as System clock source and configure HCLK, PCLK2
  *         and PCLK1 prescalers.
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
static void SetSysClockToHSE(void)
{
    __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
    /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration */
    /* Enable HSE */
#if  (SYSCLK_SOURCE ==SYSCLK_SRC_HSE_BYPASS)
    RCC->CR |= ((uint32_t)RCC_CR_HSEON | RCC_CR_HSEBYP);
#else
    RCC->CR |= ((uint32_t)RCC_CR_HSEON);
#endif

    /* Wait till HSE is ready and if Time out is reached exit */
    do
    {
        HSEStatus = RCC->CR & RCC_CR_HSERDY;
        StartUpCounter++;
    } while ((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));

    if ((RCC->CR & RCC_CR_HSERDY) != RESET)
    {
        HSEStatus = (uint32_t)0x01;
    }
    else
    {
        HSEStatus = (uint32_t)0x00;
    }

    if (HSEStatus == (uint32_t)0x01)
    {
        /* Enable Prefetch Buffer */
        FLASH->ACR |= FLASH_ACR_PRFTBE;
        /* Flash 0 wait state */
        FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);

        if (HSE_VALUE <= 24000000)
        {
            FLASH->ACR |= (uint32_t)FLASH_Latency_0;
        }
        else
        {
            if (HSE_VALUE <= 48000000)
            {
                FLASH->ACR |= (uint32_t)FLASH_Latency_1;
            }
        }

        /* HCLK = SYSCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_HPRE_Pos;
        /* PCLK1 = HCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_PPRE_Pos;
        /* Select HSE as system clock source */
        RCC->CFGR4 &= ~RCC_CFGR4_ESSS;
        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
        RCC->CFGR |= (uint32_t)0x1 << RCC_CFGR_SW_Pos;

        /* Wait till HSE is used as system clock source */
        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != ((uint32_t)0x1 << RCC_CFGR_SWS_Pos))
        {
        }
    }
    else
    {
        /* If HSE fails to start-up, the application will have wrong clock configuration. User can add here some code to deal with this error */
    }
}
#elif defined SYSCLK_HSE8M_PLL_FREQ_24MHz

/**
  * @brief  Selects HSE_PLL as System clock source and configure HCLK, PCLK2
  *         and PCLK1 prescalers.
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
static void SetSysClockTo24_HSE8M_PLL(void)
{
    __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
    /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration */
    /* Enable HSE */
    RCC->CR |= ((uint32_t)RCC_CR_HSEON);

    /* Wait till HSE is ready and if Time out is reached exit */
    do
    {
        HSEStatus = RCC->CR & RCC_CR_HSERDY;
        StartUpCounter++;
    } while ((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));

    if ((RCC->CR & RCC_CR_HSERDY) != RESET)
    {
        HSEStatus = (uint32_t)0x01;
    }
    else
    {
        HSEStatus = (uint32_t)0x00;
    }

    if (HSEStatus == (uint32_t)0x01)
    {
        /* Enable Prefetch Buffer */
        FLASH->ACR |= FLASH_ACR_PRFTBE;
        /* Flash 0 wait state */
        FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
        FLASH->ACR |= (uint32_t)FLASH_Latency_0;
        /* HCLK = SYSCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_HPRE_Pos;
        /* PCLK1 = HCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_PPRE_Pos;
        //RCC_CFGR4.PPSS = 0(HSE) PREDIV = 1  PLLSRC = 1  PLLMUL = 3  8M/1 * 3 = 24M
        RCC->CFGR4 &= (uint32_t)((uint32_t)~(RCC_CFGR4_PPSS ));
        //RCC->CFGR4 |= (uint32_t)(RCC_CFGR4_PPSS_HSE );
        RCC->CFGR2 &= (uint32_t)((uint32_t)~(RCC_CFGR2_PREDIV_Mask));
        RCC->CFGR2 |= (uint32_t)(RCC_PREDIV1_Div1);                //PLLXTPREandRCC_CFGR2.PREDIV[0]
        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLMUL));
        RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC | RCC_PLLMul_3 );
        /* Enable PLL */
        RCC->CR |= RCC_CR_PLLON;

        /* Wait till PLL is ready */
        while ((RCC->CR & RCC_CR_PLLRDY) == 0)
        {
        }

        /* Select PLL as system clock source */
        RCC->CFGR4 &= ~RCC_CFGR4_ESSS;
        /* Select PLL as system clock source */
        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
        RCC->CFGR |= (uint32_t)0x2 << RCC_CFGR_SW_Pos;

        /* Wait till PLL is used as system clock source */
        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != ((uint32_t)0x2 << RCC_CFGR_SWS_Pos))
        {
        }
    }
    else
    {
        /* If HSE fails to start-up, the application will have wrong clock
           configuration. User can add here some code to deal with this error */
    }
}
#elif defined SYSCLK_HSE8M_PLL_FREQ_48MHz

/**
  * @brief  Selects HSE_PLL as System clock source and configure HCLK, PCLK2
  *         and PCLK1 prescalers.
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
static void SetSysClockTo48_HSE8M_PLL(void)
{
    __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
    /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration */
    /* Enable HSE */
    RCC->CR |= ((uint32_t)RCC_CR_HSEON);

    /* Wait till HSE is ready and if Time out is reached exit */
    do
    {
        HSEStatus = RCC->CR & RCC_CR_HSERDY;
        StartUpCounter++;
    } while ((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));

    if ((RCC->CR & RCC_CR_HSERDY) != RESET)
    {
        HSEStatus = (uint32_t)0x01;
    }
    else
    {
        HSEStatus = (uint32_t)0x00;
    }

    if (HSEStatus == (uint32_t)0x01)
    {
        /* Enable Prefetch Buffer */
        FLASH->ACR |= FLASH_ACR_PRFTBE;
        /* Flash 0 wait state */
        FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
        FLASH->ACR |= (uint32_t)FLASH_Latency_1;
        /* HCLK = SYSCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_HPRE_Pos;
        /* PCLK1 = HCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_PPRE_Pos;
        //RCC_CFGR4.PPSS = 0(set HSE) PREDIV = 1  PLLSRC = 1  PLLMUL = 6  8M/1 * 6 = 48M
        RCC->CFGR4 &= (uint32_t)((uint32_t)~(RCC_CFGR4_PPSS ));
        //RCC->CFGR4 |= (uint32_t)(RCC_CFGR4_PPSS_HSE );
        RCC->CFGR2 &= (uint32_t)((uint32_t)~(RCC_CFGR2_PREDIV_Mask));
        RCC->CFGR2 |= (uint32_t)(RCC_PREDIV1_Div1);                               //PLLXTPREandRCC_CFGR2.PREDIV[0]right
        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLMUL));
        RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC | RCC_PLLMul_6 );
        /* Enable PLL */
        RCC->CR |= RCC_CR_PLLON;

        /* Wait till PLL is ready */
        while ((RCC->CR & RCC_CR_PLLRDY) == 0)
        {
        }

        /* Select PLL as system clock source */
        RCC->CFGR4 &= ~RCC_CFGR4_ESSS;
        /* Select PLL as system clock source */
        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
        RCC->CFGR |= (uint32_t)0x2 << RCC_CFGR_SW_Pos;

        /* Wait till PLL is used as system clock source */
        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != ((uint32_t)0x2 << RCC_CFGR_SWS_Pos))
        {
        }
    }
    else
    {
        /* If HSE fails to start-up, the application will have wrong clock
           configuration. User can add here some code to deal with this error */
    }
}
#elif defined SYSCLK_HSE8M_PLL_FREQ_72MHz

/**
  * @brief  Selects HSE_PLL as System clock source and configure HCLK, PCLK2
  *         and PCLK1 prescalers.
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
static void SetSysClockTo72_HSE8M_PLL(void)
{
    __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
    /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration */
    /* Enable HSE */
    RCC->CR |= ((uint32_t)RCC_CR_HSEON);

    /* Wait till HSE is ready and if Time out is reached exit */
    do
    {
        HSEStatus = RCC->CR & RCC_CR_HSERDY;
        StartUpCounter++;
    } while ((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));

    if ((RCC->CR & RCC_CR_HSERDY) != RESET)
    {
        HSEStatus = (uint32_t)0x01;
    }
    else
    {
        HSEStatus = (uint32_t)0x00;
    }

    if (HSEStatus == (uint32_t)0x01)
    {
        /* Enable Prefetch Buffer */
        FLASH->ACR |= FLASH_ACR_PRFTBE;
        /* Flash 0 wait state */
        FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
        FLASH->ACR |= (uint32_t)FLASH_Latency_2;
        /* HCLK = SYSCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_HPRE_Pos;
        /* PCLK1 = HCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_PPRE_Pos;
        //RCC_CFGR4.PPSS = 0(set HSE) PREDIV = 1  PLLSRC = 1  PLLMUL = 9  8M/1 * 9 = 72M
        RCC->CFGR4 &= (uint32_t)((uint32_t)~(RCC_CFGR4_PPSS ));
        //RCC->CFGR4 |= (uint32_t)(RCC_CFGR4_PPSS_HSE );
        RCC->CFGR2 &= (uint32_t)((uint32_t)~(RCC_CFGR2_PREDIV_Mask));
        RCC->CFGR2 |= (uint32_t)(RCC_PREDIV1_Div1);                               //PLLXTPREandRCC_CFGR2.PREDIV[0]right
        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLMUL));
        RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC | RCC_PLLMul_9 );
        /* Enable PLL */
        RCC->CR |= RCC_CR_PLLON;

        /* Wait till PLL is ready */
        while ((RCC->CR & RCC_CR_PLLRDY) == 0)
        {
        }

        /* Select PLL as system clock source */
        RCC->CFGR4 &= ~RCC_CFGR4_ESSS;
        /* Select PLL as system clock source */
        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
        RCC->CFGR |= (uint32_t)0x2 << RCC_CFGR_SW_Pos;

        /* Wait till PLL is used as system clock source */
        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != ((uint32_t)0x2 << RCC_CFGR_SWS_Pos))
        {
        }
    }
    else
    {
        /* If HSE fails to start-up, the application will have wrong clock
           configuration. User can add here some code to deal with this error */
    }
}
#elif defined SYSCLK_HSE8M_PLL_FREQ_96MHz

/**
  * @brief  Selects HSE_PLL as System clock source and configure HCLK, PCLK2
  *         and PCLK1 prescalers.
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
static void SetSysClockTo96_HSE8M_PLL(void)
{
    __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
    /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration */
    /* Enable HSE */
    RCC->CR |= ((uint32_t)RCC_CR_HSEON);

    /* Wait till HSE is ready and if Time out is reached exit */
    do
    {
        HSEStatus = RCC->CR & RCC_CR_HSERDY;
        StartUpCounter++;
    } while ((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));

    if ((RCC->CR & RCC_CR_HSERDY) != RESET)
    {
        HSEStatus = (uint32_t)0x01;
    }
    else
    {
        HSEStatus = (uint32_t)0x00;
    }

    if (HSEStatus == (uint32_t)0x01)
    {
        /* Enable Prefetch Buffer */
        FLASH->ACR |= FLASH_ACR_PRFTBE;
        /* Flash 0 wait state */
        FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
        FLASH->ACR |= (uint32_t)FLASH_Latency_3;
        /* HCLK = SYSCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_HPRE_Pos;
        /* PCLK1 = HCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_PPRE_Pos;
        //RCC_CFGR4.PPSS = 0(set HSE) PREDIV = 1  PLLSRC = 1  PLLMUL = 12 8M/1 * 3 = 96M
        RCC->CFGR4 &= (uint32_t)((uint32_t)~(RCC_CFGR4_PPSS ));
        //RCC->CFGR4 |= (uint32_t)(RCC_CFGR4_PPSS_HSE );
        RCC->CFGR2 &= (uint32_t)((uint32_t)~(RCC_CFGR2_PREDIV_Mask));
        RCC->CFGR2 |= (uint32_t)(RCC_PREDIV1_Div1);                               //PLLXTPREandRCC_CFGR2.PREDIV[0]right
        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLMUL));
        RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC | RCC_PLLMul_12 );
        /* Enable PLL */
        RCC->CR |= RCC_CR_PLLON;

        /* Wait till PLL is ready */
        while ((RCC->CR & RCC_CR_PLLRDY) == 0)
        {
        }

        /* Select PLL as system clock source */
        RCC->CFGR4 &= ~RCC_CFGR4_ESSS;
        /* Select PLL as system clock source */
        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
        RCC->CFGR |= (uint32_t)0x2 << RCC_CFGR_SW_Pos;

        /* Wait till PLL is used as system clock source */
        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != ((uint32_t)0x2 << RCC_CFGR_SWS_Pos))
        {
        }
    }
    else
    {
        /* If HSE fails to start-up, the application will have wrong clock
           configuration. User can add here some code to deal with this error */
    }
}
#elif defined SYSCLK_HSI_PLL_FREQ_48MHz

/**
  * @brief  Selects HSE_PLL as System clock source and configure HCLK, PCLK2
  *         and PCLK1 prescalers.
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
static void SetSysClockTo48_HSI_PLL(void)
{
    __IO uint32_t StartUpCounter = 0, HSIStatus = 0;
    /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration */
    /* Enable HSI */
    RCC->CR |= ((uint32_t)RCC_CR_HSION);

    /* Wait till HSE is ready and if Time out is reached exit */
    do
    {
        HSIStatus = RCC->CR & RCC_CR_HSIRDY;
        StartUpCounter++;
    } while ((HSIStatus == 0) && (StartUpCounter != HSI_STARTUP_TIMEOUT));

    if ((RCC->CR & RCC_CR_HSIRDY) != RESET)
    {
        HSIStatus = (uint32_t)0x01;
    }
    else
    {
        HSIStatus = (uint32_t)0x00;
    }

    if (HSIStatus == (uint32_t)0x01)
    {
        /* Enable Prefetch Buffer */
        FLASH->ACR |= FLASH_ACR_PRFTBE;
        /* Flash 0 wait state */
        FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
        FLASH->ACR |= (uint32_t)FLASH_Latency_1;
        /* HCLK = SYSCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_HPRE_Pos;
        /* PCLK = HCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_PPRE_Pos;
        //HSI=8M RCC_CFGR4.PPSS = 0(set HSE) PREDIV = 1  PLLSRC = 0 (HSI/2) PLLMUL = 12 4M/1 * 12 = 48M
        RCC->CFGR4 &= (uint32_t)((uint32_t)~(RCC_CFGR4_PPSS ));  //0
        //RCC->CFGR4 |= (uint32_t)(RCC_CFGR4_PPSS );
        RCC->CFGR2 &= (uint32_t)((uint32_t)~(RCC_CFGR2_PREDIV_Mask));
        RCC->CFGR2 |= (uint32_t)(RCC_PREDIV1_Div1);                                     //PLLXTPREandRCC_CFGR2.PREDIV[0]right
        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLMUL));
        // RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC));
        RCC->CFGR |= (uint32_t)(RCC_PLLMul_12 );
        /* Enable PLL */
        RCC->CR |= RCC_CR_PLLON;

        /* Wait till PLL is ready */
        while ((RCC->CR & RCC_CR_PLLRDY) == 0)
        {
        }

        /* Select PLL as system clock source */
        RCC->CFGR4 &= ~RCC_CFGR4_ESSS;
        /* Select PLL as system clock source */
        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
        RCC->CFGR |= (uint32_t)0x2 << RCC_CFGR_SW_Pos;

        /* Wait till PLL is used as system clock source */
        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != ((uint32_t)0x2 << RCC_CFGR_SWS_Pos))
        {
        }
    }
    else
    {
        /* If HSE fails to start-up, the application will have wrong clock
        configuration. User can add here some code to deal with this error */
    }
}
#elif defined SYSCLK_HSI_PLL_FREQ_64MHz

/**
  * @brief  Selects HSI as System clock source and configure HCLK, PCLK2
  *         and PCLK1 prescalers.
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
static void SetSysClockTo64_HSI_PLL(void)
{
    __IO uint32_t StartUpCounter = 0, HSIStatus = 0;
    /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration */
    /* Enable HSI */
    RCC->CR |= ((uint32_t)RCC_CR_HSION);

    /* Wait till HSE is ready and if Time out is reached exit */
    do
    {
        HSIStatus = RCC->CR & RCC_CR_HSIRDY;
        StartUpCounter++;
    } while ((HSIStatus == 0) && (StartUpCounter != HSI_STARTUP_TIMEOUT));

    if ((RCC->CR & RCC_CR_HSIRDY) != RESET)
    {
        HSIStatus = (uint32_t)0x01;
    }
    else
    {
        HSIStatus = (uint32_t)0x00;
    }

    if (HSIStatus == (uint32_t)0x01)
    {
        /* Enable Prefetch Buffer */
        FLASH->ACR |= FLASH_ACR_PRFTBE;
        /* Flash 0 wait state */
        FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
        FLASH->ACR |= (uint32_t)FLASH_Latency_2;
        /* HCLK = SYSCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_HPRE_Pos;
        /* PCLK = HCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_PPRE_Pos;
        //HSI=8M RCC_CFGR4.PPSS = 1(set HSI) PREDIV = 1  PLLSRC = 1          PLLMUL = 8  8M/1 * 8 = 64M
        RCC->CFGR4 &= (uint32_t)((uint32_t)~(RCC_CFGR4_PPSS ));
        RCC->CFGR4 |= (uint32_t)(RCC_CFGR4_PPSS );   //1
        RCC->CFGR2 &= (uint32_t)((uint32_t)~(RCC_CFGR2_PREDIV_Mask));
        RCC->CFGR2 |= (uint32_t)(RCC_PREDIV1_Div1);                               //PLLXTPREandRCC_CFGR2.PREDIV[0]right
        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLMUL));
        RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC | RCC_PLLMul_8 );
        /* Enable PLL */
        RCC->CR |= RCC_CR_PLLON;

        /* Wait till PLL is ready */
        while ((RCC->CR & RCC_CR_PLLRDY) == 0)
        {
        }

        /* Select PLL as system clock source */
        RCC->CFGR4 &= ~RCC_CFGR4_ESSS;
        /* Select PLL as system clock source */
        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
        RCC->CFGR |= (uint32_t)0x2 << RCC_CFGR_SW_Pos;

        /* Wait till PLL is used as system clock source */
        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != ((uint32_t)0x2 << RCC_CFGR_SWS_Pos))
        {
        }
    }
    else
    {
        /* If HSE fails to start-up, the application will have wrong clock
        configuration. User can add here some code to deal with this error */
    }
}
#elif defined SYSCLK_HSI_PLL_FREQ_72MHz

/**
  * @brief  Selects HSI_PLL as System clock source and configure HCLK, PCLK2
  *         and PCLK1 prescalers.
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
static void SetSysClockTo72_HSI_PLL(void)
{
    __IO uint32_t StartUpCounter = 0, HSIStatus = 0;
    /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration */
    /* Enable HSI */
    RCC->CR |= ((uint32_t)RCC_CR_HSION);

    /* Wait till HSE is ready and if Time out is reached exit */
    do
    {
        HSIStatus = RCC->CR & RCC_CR_HSIRDY;
        StartUpCounter++;
    } while ((HSIStatus == 0) && (StartUpCounter != HSI_STARTUP_TIMEOUT));

    if ((RCC->CR & RCC_CR_HSIRDY) != RESET)
    {
        HSIStatus = (uint32_t)0x01;
    }
    else
    {
        HSIStatus = (uint32_t)0x00;
    }

    if (HSIStatus == (uint32_t)0x01)
    {
        /* Enable Prefetch Buffer */
        FLASH->ACR |= FLASH_ACR_PRFTBE;
        /* Flash 0 wait state */
        FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
        FLASH->ACR |= (uint32_t)FLASH_Latency_2;
        /* HCLK = SYSCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_HPRE_Pos;
        /* PCLK = HCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_PPRE_Pos;
        //HSI=8M RCC_CFGR4.PPSS = 1(set HSI) PREDIV = 1  PLLSRC = 1          PLLMUL = 9  8M/1 * 9 = 72M
        RCC->CFGR4 &= (uint32_t)((uint32_t)~(RCC_CFGR4_PPSS ));
        RCC->CFGR4 |= (uint32_t)(RCC_CFGR4_PPSS ); //1
        RCC->CFGR2 &= (uint32_t)((uint32_t)~(RCC_CFGR2_PREDIV_Mask));
        RCC->CFGR2 |= (uint32_t)(RCC_PREDIV1_Div1);                               //PLLXTPREandRCC_CFGR2.PREDIV[0]right
        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLMUL));
        RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC | RCC_PLLMul_9 );
        /* Enable PLL */
        RCC->CR |= RCC_CR_PLLON;

        /* Wait till PLL is ready */
        while ((RCC->CR & RCC_CR_PLLRDY) == 0)
        {
        }

        /* Select PLL as system clock source */
        RCC->CFGR4 &= ~RCC_CFGR4_ESSS;
        /* Select PLL as system clock source */
        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
        RCC->CFGR |= (uint32_t)0x2 << RCC_CFGR_SW_Pos;

        /* Wait till PLL is used as system clock source */
        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != ((uint32_t)0x2 << RCC_CFGR_SWS_Pos))
        {
        }
    }
    else
    {
        /* If HSE fails to start-up, the application will have wrong clock
        configuration. User can add here some code to deal with this error */
    }
}
#elif defined SYSCLK_HSI_PLL_FREQ_96MHz

/**
  * @brief  Selects HSI_PLL as System clock source and configure HCLK, PCLK2
  *         and PCLK1 prescalers.
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
static void SetSysClockTo96_HSI_PLL(void)
{
    __IO uint32_t StartUpCounter = 0, HSIStatus = 0;
    /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration */
    /* Enable HSI */
    RCC->CR |= ((uint32_t)RCC_CR_HSION);

    /* Wait till HSE is ready and if Time out is reached exit */
    do
    {
        HSIStatus = RCC->CR & RCC_CR_HSIRDY;
        StartUpCounter++;
    } while ((HSIStatus == 0) && (StartUpCounter != HSI_STARTUP_TIMEOUT));

    if ((RCC->CR & RCC_CR_HSIRDY) != RESET)
    {
        HSIStatus = (uint32_t)0x01;
    }
    else
    {
        HSIStatus = (uint32_t)0x00;
    }

    if (HSIStatus == (uint32_t)0x01)
    {
        /* Enable Prefetch Buffer */
        FLASH->ACR |= FLASH_ACR_PRFTBE;
        /* Flash 0 wait state */
        FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
        FLASH->ACR |= (uint32_t)FLASH_Latency_3;
        /* HCLK = SYSCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_HPRE_Pos;
        /* PCLK = HCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_PPRE_Pos;
        //HSI=8M RCC_CFGR4.PPSS = 1(set HSI) PREDIV = 1  PLLSRC = 1          PLLMUL = 12 8M/1 * 8 = 96M
        RCC->CFGR4 &= (uint32_t)((uint32_t)~(RCC_CFGR4_PPSS ));
        RCC->CFGR4 |= (uint32_t)(RCC_CFGR4_PPSS );
        RCC->CFGR2 &= (uint32_t)((uint32_t)~(RCC_CFGR2_PREDIV_Mask));
        RCC->CFGR2 |= (uint32_t)(RCC_PREDIV1_Div1);                               //PLLXTPREandRCC_CFGR2.PREDIV[0]right
        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLMUL));
        RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC | RCC_PLLMul_12 );
        /* Enable PLL */
        RCC->CR |= RCC_CR_PLLON;

        /* Wait till PLL is ready */
        while ((RCC->CR & RCC_CR_PLLRDY) == 0)
        {
        }

        /* Select PLL as system clock source */
        RCC->CFGR4 &= ~RCC_CFGR4_ESSS;
        /* Select PLL as system clock source */
        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
        RCC->CFGR |= (uint32_t)0x2 << RCC_CFGR_SW_Pos;

        /* Wait till PLL is used as system clock source */
        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != ((uint32_t)0x2 << RCC_CFGR_SWS_Pos))
        {
        }
    }
    else
    {
        /* If HSE fails to start-up, the application will have wrong clock
        configuration. User can add here some code to deal with this error */
    }
}
#elif defined SYSCLK_FREQ_EXTCLK

/**
  * @brief  Selects EXTCLK as System clock source and configure HCLK, PCLK2
  *         and PCLK1 prescalers.
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
static void SetSysClockToEXTCLK(void)
{
    /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration */
    /* Enable EXCLK */
    //enable EXTIO PA4/PA13/PA14/PA0
    /* Configure PA4 as CLOCK input */
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
    /*CLOCK select */
    RCC->CFGR4 &= (uint32_t)((uint32_t)~(RCC_CFGR4_EXTCLK_SEL));
    RCC->CFGR4 |= (uint32_t)0x0 << RCC_CFGR4_EXTCLK_SEL_Pos;
    /* Enable Prefetch Buffer */
    FLASH->ACR |= FLASH_ACR_PRFTBE;
    /* Flash wait state */
    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
    FLASH->ACR |= (uint32_t)FLASH_Latency_1;
    /* HCLK = SYSCLK */
    RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_HPRE_Pos;
    /* PCLK1 = HCLK */
    RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_PPRE_Pos;
    /* Select EXTCLK as system clock source */
    RCC->CFGR4 |= RCC_CFGR4_ESSS;
    RCC->CFGR4 &= (uint32_t)((uint32_t)~(RCC_CFGR4_ESW));
    RCC->CFGR4 |= (uint32_t)0x4 << RCC_CFGR4_ESW_Pos;

    /* Wait till EXTCLK is used as system clock source */
    while ((RCC->CFGR4 & (uint32_t)RCC_CFGR4_ESWS) != ((uint32_t)0x4 << RCC_CFGR4_ESWS_Pos))
    {
    }
}
#elif defined SYSCLK_FREQ_HSI_56M

/**
  * @brief  Selects HSI as System clock source and configure HCLK, PCLK2
  *         and PCLK1 prescalers.
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
static void SetSysClockToHSI_56M(void)
{
    __IO uint32_t StartUpCounter = 0, HSIStatus = 0;
    /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration */
    /* Enable HSI */
    RCC->CFGR4 |= ((uint32_t)RCC_CFGR4_HSI56ON);

    /* Wait till HSE is ready and if Time out is reached exit */
    do
    {
        HSIStatus = RCC->CFGR4 & RCC_CFGR4_HSI56RDY;
        StartUpCounter++;
    } while ((HSIStatus == 0) && (StartUpCounter != HSI_STARTUP_TIMEOUT));

    if ((RCC->CFGR4 & RCC_CFGR4_HSI56RDY) != RESET)
    {
        HSIStatus = (uint32_t)0x01;
    }
    else
    {
        HSIStatus = (uint32_t)0x00;
    }

    if (HSIStatus == (uint32_t)0x01)
    {
        /* Enable Prefetch Buffer */
        FLASH->ACR |= FLASH_ACR_PRFTBE;
        /* Flash 1 wait state */
        FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
        FLASH->ACR |= (uint32_t)FLASH_Latency_2;
        /* HCLK = SYSCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_HPRE_Pos;
        /* PCLK = HCLK/2 */
        RCC->CFGR |= (uint32_t)0x4 << RCC_CFGR_PPRE_Pos;
        /* Select HSI56 as system clock source */
        RCC->CFGR4 |= RCC_CFGR4_ESSS;
        RCC->CFGR4 &= ~(RCC_CFGR4_ESW);
        RCC->CFGR4 |= (uint32_t)0x2 << RCC_CFGR4_ESW_Pos;

        /* Wait till HSI is used as system clock source */
        while ((RCC->CFGR4 & (uint32_t)RCC_CFGR4_ESWS) != ((uint32_t)0x2 << RCC_CFGR4_ESWS_Pos))
        {
        }
    }
    else
    {
        /* If fails to start-up */
    }
}

#elif defined SYSCLK_FREQ_HSI_14M

/**
  * @brief  Selects HSI as System clock source and configure HCLK, PCLK2
  *         and PCLK1 prescalers.
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
static void SetSysClockToHSI_14M(void)
{
    __IO uint32_t StartUpCounter = 0, HSIStatus = 0;
    /* SYSCLK, HCLK, PCLK configuration */
    /* Enable HSI */
    RCC->CR2 |= ((uint32_t)RCC_CR2_HSI14ON);

    /* Wait till HSE is ready and if Time out is reached exit */
    do
    {
        HSIStatus = RCC->CR2 & RCC_CR2_HSI14RDY;
        StartUpCounter++;
    } while ((HSIStatus == 0) && (StartUpCounter != HSI_STARTUP_TIMEOUT));

    if ((RCC->CR2 & RCC_CR2_HSI14RDY) != RESET)
    {
        HSIStatus = (uint32_t)0x01;
    }
    else
    {
        HSIStatus = (uint32_t)0x00;
    }

    if (HSIStatus == (uint32_t)0x01)
    {
        /* Enable Prefetch Buffer */
        FLASH->ACR |= FLASH_ACR_PRFTBE;
        /* Flash 0 wait state */
        FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
        FLASH->ACR |= (uint32_t)FLASH_Latency_0;
        /* HCLK = SYSCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_HPRE_Pos;
        /* PCLK = HCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_PPRE_Pos;
        /* Select HSI14 as system clock source */
        RCC->CFGR4 |= RCC_CFGR4_ESSS;
        RCC->CFGR4 &= ~(RCC_CFGR4_ESW);
        RCC->CFGR4 |= (uint32_t)0x3 << RCC_CFGR4_ESW_Pos;

        /* Wait till HSI is used as system clock source */
        while ((RCC->CFGR4 & (uint32_t)RCC_CFGR4_ESWS) != ((uint32_t)0x3 << RCC_CFGR4_ESWS_Pos))
        {
        }
    }
    else
    {
        /* If fails to start-up */
    }
}

#elif defined SYSCLK_FREQ_HSI_8M

/**
  * @brief  Selects HSI as System clock source and configure HCLK, PCLK2
  *         and PCLK1 prescalers.
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
static void SetSysClockToHSI_8M(void)
{
    __IO uint32_t StartUpCounter = 0, HSIStatus = 0;
    /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration */
    /* Enable HSI */
    RCC->CR |= ((uint32_t)RCC_CR_HSION);

    /* Wait till HSE is ready and if Time out is reached exit */
    do
    {
        HSIStatus = RCC->CR & RCC_CR_HSIRDY;
        StartUpCounter++;
    } while ((HSIStatus == 0) && (StartUpCounter != HSI_STARTUP_TIMEOUT));

    if ((RCC->CR & RCC_CR_HSIRDY) != RESET)
    {
        HSIStatus = (uint32_t)0x01;
    }
    else
    {
        HSIStatus = (uint32_t)0x00;
    }

    if (HSIStatus == (uint32_t)0x01)
    {
        /* Enable Prefetch Buffer */
        FLASH->ACR |= FLASH_ACR_PRFTBE;
        /* Flash 0 wait state */
        FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
        FLASH->ACR |= (uint32_t)FLASH_Latency_0;
        /* HCLK = SYSCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_HPRE_Pos;
        /* PCLK = HCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_PPRE_Pos;
        /* Select HSI as system clock source */
        RCC->CFGR4 &= ~RCC_CFGR4_ESSS;
        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_SW_Pos;

        /* Wait till HSI is used as system clock source */
        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != ((uint32_t)0x0 << RCC_CFGR_SWS_Pos))
        {
        }
    }
    else
    {
        /* If fails to start-up */
    }
}



#elif defined SYSCLK_FREQ_LSI

/**
  * @brief  Selects LSI as System clock source and configure HCLK, PCLK2
  *         and PCLK1 prescalers.
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
static void SetSysClockToLSI(void)
{
    __IO uint32_t StartUpCounter = 0, LSIStatus = 0;
    /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration */
    /* Enable LSI */
    RCC->CSR |= RCC_CSR_LSION;

    /* Wait till HSE is ready and if Time out is reached exit */
    do
    {
        LSIStatus = RCC->CSR & RCC_CSR_LSIRDY;
        StartUpCounter++;
    } while ((LSIStatus == 0) && (StartUpCounter != 0xFFFF));

    if ((RCC->CSR & RCC_CSR_LSIRDY) != RESET)
    {
        LSIStatus = (uint32_t)0x01;
    }
    else
    {
        LSIStatus = (uint32_t)0x00;
    }

    if (LSIStatus == (uint32_t)0x01)
    {
        /* Enable Prefetch Buffer */
        FLASH->ACR |= FLASH_ACR_PRFTBE;
        /* Flash 0 wait state */
        FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
        FLASH->ACR |= (uint32_t)FLASH_Latency_0;
        /* HCLK = SYSCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_HPRE_Pos;
        /* PCLK = HCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_PPRE_Pos;
        /* Select LSI as system clock source */
        RCC->CFGR4 |= RCC_CFGR4_ESSS;
        RCC->CFGR4 &= ~(RCC_CFGR4_ESW);
        RCC->CFGR4 |= (uint32_t)0x1 << RCC_CFGR4_ESW_Pos;

        /* Wait till HSI is used as system clock source */
        while ((RCC->CFGR4 & (uint32_t)RCC_CFGR4_ESWS) != ((uint32_t)0x1 << RCC_CFGR4_ESWS_Pos))
        {
        }
    }
    else
    {
        /* If fails to start-up */
    }
}
#elif defined SYSCLK_FREQ_LSE

/**
  * @brief  Selects LSE as System clock source and configure HCLK, PCLK2
  *         and PCLK1 prescalers.
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
static void SetSysClockToLSE(void)
{
    __IO uint32_t StartUpCounter = 0, LSEStatus = 0;
    /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration */
    /* Enable LSE */
    RCC_APB1PeriphClockCmd( RCC_APB1Periph_PWR, ENABLE );
    PWR->CR |= PWR_CR_DBP;
    //RCC->BDCR |= RCC_LSE_Bypass | RCC_LSE_ON;
    RCC->BDCR |= RCC_LSE_ON;

    /* Wait till HSE is ready and if Time out is reached exit */
    do
    {
        LSEStatus = RCC->BDCR & RCC_BDCR_LSERDY;
        StartUpCounter++;
    } while ((LSEStatus == 0) && (StartUpCounter != 0xFFFFF));

    if ((RCC->BDCR & RCC_BDCR_LSERDY) != RESET)
    {
        LSEStatus = (uint32_t)0x01;
    }
    else
    {
        LSEStatus = (uint32_t)0x00;
    }

    if (LSEStatus == (uint32_t)0x01)
    {
        /* Enable Prefetch Buffer */
        FLASH->ACR |= FLASH_ACR_PRFTBE;
        /* Flash 0 wait state */
        FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
        FLASH->ACR |= (uint32_t)FLASH_Latency_0;
        /* HCLK = SYSCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_HPRE_Pos;
        /* PCLK = HCLK */
        RCC->CFGR |= (uint32_t)0x0 << RCC_CFGR_PPRE_Pos;
        /* Select LSE as system clock source */
        RCC->CFGR4 |= RCC_CFGR4_ESSS;
        RCC->CFGR4 &= ~(RCC_CFGR4_ESW);
        RCC->CFGR4 |= (uint32_t)0x0 << RCC_CFGR4_ESW_Pos;

        /* Wait till HSI is used as system clock source */
        while ((RCC->CFGR4 & (uint32_t)RCC_CFGR4_ESWS) != ((uint32_t)0x0 << RCC_CFGR4_ESWS_Pos))
        {
        }
    }
    else
    {
        /* If fails to start-up */
    }
}

#endif
